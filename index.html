<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GradeAI v2 ‚Äî Bubble Sheet Grader</title>

<style>
@import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=IBM+Plex+Mono:ital,wght@0,400;0,500;0,600;1,400&display=swap');

:root {
  --bg: #f5f0e8;
  --paper: #fdfaf4;
  --ink: #1a1208;
  --ink2: #3d3420;
  --muted: #8c7e66;
  --border: #d4c9b0;
  --accent: #c8410a;
  --accent2: #1a6b3c;
  --accent3: #1a3f6b;
  --warn: #b87a00;
  --surface: #ede8de;
  --surface2: #e4ddd0;
}

* { margin:0; padding:0; box-sizing:border-box; }

body {
  background: var(--bg);
  background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h60v60H0z' fill='none'/%3E%3Ccircle cx='1' cy='1' r='0.8' fill='%23c4b898' opacity='0.4'/%3E%3C/svg%3E");
  color: var(--ink);
  font-family: 'IBM Plex Mono', monospace;
  min-height: 100vh;
}

.page { max-width: 960px; margin: 0 auto; padding: 40px 24px 100px; }

/* ‚îÄ‚îÄ HEADER ‚îÄ‚îÄ */
header {
  border-bottom: 3px solid var(--ink);
  padding-bottom: 24px;
  margin-bottom: 40px;
  display: flex;
  align-items: flex-end;
  justify-content: space-between;
  flex-wrap: wrap;
  gap: 16px;
}
.brand { display:flex; align-items:baseline; gap:12px; }
.brand h1 {
  font-family: 'Bebas Neue', sans-serif;
  font-size: 64px;
  letter-spacing: 0.02em;
  line-height: 1;
  color: var(--ink);
}
.brand .version {
  font-size: 10px; letter-spacing: 0.15em; text-transform: uppercase;
  color: var(--accent); border: 1.5px solid var(--accent);
  padding: 3px 8px; border-radius: 2px;
}
.header-sub {
  font-size: 11px; color: var(--muted); letter-spacing: 0.08em;
  text-align: right; line-height: 1.6;
}

/* ‚îÄ‚îÄ PIPELINE ‚îÄ‚îÄ */
.pipeline {
  display: flex;
  gap: 0;
  margin-bottom: 40px;
  border: 2px solid var(--ink);
  border-radius: 4px;
  overflow: hidden;
}
.pipe-step {
  flex: 1;
  padding: 14px 16px;
  background: var(--surface);
  border-right: 2px solid var(--ink);
  transition: .3s;
  cursor: default;
}
.pipe-step:last-child { border-right: none; }
.pipe-step.done { background: var(--ink); color: var(--bg); }
.pipe-step.active { background: var(--accent); color: white; }
.pipe-num { font-family:'Bebas Neue'; font-size:22px; line-height:1; }
.pipe-label { font-size:9px; letter-spacing:0.1em; text-transform:uppercase; margin-top:2px; opacity:0.7; }

/* ‚îÄ‚îÄ PANELS ‚îÄ‚îÄ */
.panel {
  background: var(--paper);
  border: 2px solid var(--ink);
  border-radius: 4px;
  margin-bottom: 20px;
  overflow: hidden;
}
.panel-head {
  background: var(--ink);
  color: var(--bg);
  padding: 12px 20px;
  font-family: 'Bebas Neue';
  font-size: 18px;
  letter-spacing: 0.08em;
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.panel-head .badge {
  font-family: 'IBM Plex Mono';
  font-size: 9px;
  letter-spacing: 0.12em;
  background: rgba(255,255,255,0.15);
  padding: 3px 8px;
  border-radius: 2px;
}
.panel-body { padding: 24px; }

/* ‚îÄ‚îÄ UPLOAD ZONES ‚îÄ‚îÄ */
.upload-zone {
  border: 2px dashed var(--border);
  border-radius: 4px;
  padding: 36px 24px;
  text-align: center;
  cursor: pointer;
  transition: .2s;
  position: relative;
  background: var(--surface);
}
.upload-zone:hover, .upload-zone.dragover {
  border-color: var(--accent);
  background: rgba(200,65,10,0.04);
}
.upload-zone input[type=file] {
  position:absolute; inset:0; opacity:0; cursor:pointer; width:100%; height:100%;
}
.upload-zone.has-file {
  border-style: solid;
  border-color: var(--accent2);
  background: rgba(26,107,60,0.04);
}
.upload-icon { font-size:32px; margin-bottom:10px; }
.upload-label { font-size:12px; color:var(--muted); }
.upload-label strong { color:var(--ink); }
.upload-label.success { color: var(--accent2); font-weight:600; }

.two-col { display:grid; grid-template-columns:1fr 1fr; gap:16px; }
@media(max-width:640px){ .two-col { grid-template-columns:1fr; } }

/* Thumbnails */
.thumb-row { display:flex; gap:12px; margin-top:16px; flex-wrap:wrap; }
.thumb {
  position:relative;
  width:80px; flex-shrink:0;
}
.thumb img {
  width:80px; height:80px; object-fit:cover;
  border: 2px solid var(--border); border-radius:4px;
}
.thumb .rm {
  position:absolute; top:-6px; right:-6px;
  width:18px; height:18px; border-radius:50%;
  background:var(--accent); color:white; border:none;
  font-size:11px; cursor:pointer; display:flex; align-items:center; justify-content:center;
  line-height:1;
}
.thumb .thumb-name {
  font-size:8px; color:var(--muted); margin-top:3px;
  overflow:hidden; text-overflow:ellipsis; white-space:nowrap; width:80px;
}
.thumb .thumb-badge {
  position:absolute; bottom:22px; left:0; right:0;
  font-size:8px; text-align:center; padding:2px;
  letter-spacing:0.05em;
}
.thumb .thumb-badge.graded { background:var(--accent2); color:white; }
.thumb .thumb-badge.error { background:var(--accent); color:white; }
.thumb .thumb-badge.pending { background:var(--warn); color:white; }

/* Key preview */
#key-preview-wrap { display:none; margin-top:16px; }
#key-preview-wrap img { max-height:220px; max-width:100%; border:2px solid var(--border); border-radius:4px; }
.key-status {
  margin-top:12px; padding:10px 14px;
  border-radius:3px; font-size:11px; letter-spacing:0.05em;
  display:none;
}
.key-status.ok { background:rgba(26,107,60,0.1); border:1px solid var(--accent2); color:var(--accent2); }
.key-status.err { background:rgba(200,65,10,0.1); border:1px solid var(--accent); color:var(--accent); }

/* ‚îÄ‚îÄ MANUAL FALLBACK ‚îÄ‚îÄ */
.toggle-manual {
  font-size:11px; color:var(--muted); cursor:pointer;
  text-decoration:underline; margin-top:12px; display:inline-block;
}
#manual-section { display:none; margin-top:16px; }
.bulk-row { display:flex; gap:8px; align-items:center; margin-bottom:12px; flex-wrap:wrap; }
.bulk-row label { font-size:11px; color:var(--muted); white-space:nowrap; }
#bulk-key {
  flex:1; min-width:180px;
  background:var(--surface); border:1.5px solid var(--border);
  color:var(--ink); font-family:'IBM Plex Mono'; font-size:12px;
  padding:8px 12px; border-radius:3px; outline:none; transition:.2s;
}
#bulk-key:focus { border-color:var(--accent3); }
#bulk-key::placeholder { color:var(--muted); }
.key-grid {
  display:grid; grid-template-columns:repeat(auto-fill,minmax(100px,1fr)); gap:6px;
  max-height:200px; overflow-y:auto;
}
.kg-item {
  display:flex; align-items:center; gap:0;
  border:1.5px solid var(--border); border-radius:3px; overflow:hidden;
}
.kg-item label {
  padding:0 8px; font-size:10px; color:var(--muted);
  background:var(--surface); border-right:1px solid var(--border);
  height:32px; display:flex; align-items:center; min-width:30px; justify-content:center;
}
.kg-item select {
  flex:1; background:var(--paper); border:none; color:var(--ink);
  font-family:'IBM Plex Mono'; font-size:12px; height:32px;
  padding:0 6px; outline:none; cursor:pointer;
}

/* ‚îÄ‚îÄ CONTROLS ‚îÄ‚îÄ */
.controls { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom:20px; }
.num-q-row { display:flex; align-items:center; gap:8px; }
.num-q-row label { font-size:11px; color:var(--muted); }
#num-questions {
  width:72px; background:var(--surface); border:1.5px solid var(--border);
  color:var(--ink); font-family:'IBM Plex Mono'; font-size:13px;
  padding:7px 10px; border-radius:3px; outline:none; text-align:center;
}

/* ‚îÄ‚îÄ BUTTONS ‚îÄ‚îÄ */
.btn {
  font-family:'Bebas Neue'; letter-spacing:0.08em; font-size:15px;
  border:none; border-radius:3px; padding:10px 22px;
  cursor:pointer; transition:.15s;
}
.btn-primary { background:var(--ink); color:var(--bg); }
.btn-primary:hover { background:var(--ink2); }
.btn-primary:disabled { opacity:0.35; cursor:not-allowed; }
.btn-danger { background:var(--accent); color:white; }
.btn-danger:hover { background:#a3330a; }
.btn-ghost {
  background:transparent; color:var(--muted);
  border:1.5px solid var(--border); font-size:13px;
}
.btn-ghost:hover { border-color:var(--ink); color:var(--ink); }
.btn-go {
  width:100%; padding:16px; font-size:20px;
  background: var(--accent);
  color:white;
  border-radius:4px;
  box-shadow: 4px 4px 0 var(--ink);
  transition:.15s;
}
.btn-go:hover:not(:disabled) { transform:translate(-2px,-2px); box-shadow:6px 6px 0 var(--ink); }
.btn-go:active:not(:disabled) { transform:translate(2px,2px); box-shadow:2px 2px 0 var(--ink); }
.btn-go:disabled { opacity:.4; cursor:not-allowed; box-shadow:none; }

/* ‚îÄ‚îÄ LOADING ‚îÄ‚îÄ */
#loading { display:none; text-align:center; padding:48px 24px; }
.spinner-wrap { position:relative; width:60px; height:60px; margin:0 auto 20px; }
.spinner-ring {
  position:absolute; inset:0; border:3px solid var(--border);
  border-top-color:var(--accent); border-radius:50%;
  animation:spin .9s linear infinite;
}
.spinner-inner {
  position:absolute; inset:8px; border:2px solid var(--border);
  border-bottom-color:var(--accent3); border-radius:50%;
  animation:spin .6s linear infinite reverse;
}
@keyframes spin { to{transform:rotate(360deg);} }
.loading-title { font-family:'Bebas Neue'; font-size:22px; letter-spacing:0.1em; color:var(--ink); margin-bottom:8px; }
.loading-sub { font-size:11px; color:var(--muted); }
.progress-bar-wrap {
  width:240px; height:6px; background:var(--surface2);
  border-radius:10px; margin:16px auto 0; overflow:hidden;
}
.progress-bar {
  height:100%; background:var(--accent); border-radius:10px;
  width:0%; transition:width .5s ease;
}

/* ‚îÄ‚îÄ RESULTS ‚îÄ‚îÄ */
#results { display:none; }

.results-summary {
  background: var(--ink);
  color: var(--bg);
  border-radius:4px;
  padding: 28px;
  margin-bottom: 24px;
  display: flex;
  gap: 32px;
  align-items: center;
  flex-wrap: wrap;
}
.summary-stat { text-align:center; }
.summary-stat .val {
  font-family:'Bebas Neue'; font-size:44px; line-height:1;
}
.summary-stat .val.accent { color: #6fffc0; }
.summary-stat .val.err { color: #ff9090; }
.summary-stat .lbl {
  font-size:9px; letter-spacing:0.12em; text-transform:uppercase;
  color: rgba(245,240,232,0.5); margin-top:2px;
}
.summary-divider { width:1px; background:rgba(255,255,255,0.15); align-self:stretch; }

/* Student result cards */
.student-results { display:grid; grid-template-columns:1fr; gap:16px; }

.student-card {
  border: 2px solid var(--border);
  border-radius:4px; overflow:hidden;
  background: var(--paper);
}
.student-card-head {
  padding:12px 16px;
  display:flex; align-items:center; gap:12px; flex-wrap:wrap;
  border-bottom:1px solid var(--border); background:var(--surface);
}
.s-thumb { width:40px; height:40px; object-fit:cover; border:1.5px solid var(--border); border-radius:3px; }
.s-name { font-family:'Bebas Neue'; font-size:18px; letter-spacing:0.05em; flex:1; }
.s-score-chip {
  padding:6px 14px; border-radius:3px; font-family:'Bebas Neue'; font-size:16px; letter-spacing:0.1em;
  border:2px solid;
}
.s-score-chip.A { border-color:var(--accent2); color:var(--accent2); }
.s-score-chip.B { border-color:var(--accent3); color:var(--accent3); }
.s-score-chip.C { border-color:var(--warn); color:var(--warn); }
.s-score-chip.D, .s-score-chip.F { border-color:var(--accent); color:var(--accent); }
.s-score-chip.ERR { border-color:var(--muted); color:var(--muted); }

.s-breakdown {
  padding:12px 16px;
  display:grid; grid-template-columns:repeat(auto-fill,minmax(130px,1fr)); gap:5px;
}
.s-item {
  display:flex; align-items:center; gap:6px;
  font-size:11px; padding:5px 8px;
  border-radius:3px; background:var(--surface);
}
.s-item.correct { background:rgba(26,107,60,0.07); }
.s-item.wrong { background:rgba(200,65,10,0.07); }
.s-item.blank { opacity:0.5; }
.s-qnum { color:var(--muted); font-size:9px; min-width:24px; }
.s-ans { font-weight:600; }
.s-item.correct .s-ans { color:var(--accent2); }
.s-item.wrong .s-ans { color:var(--accent); }
.s-keyans { color:var(--muted); font-size:9px; }
.s-icon { margin-left:auto; }

.error-note {
  padding:10px 16px; font-size:11px; color:var(--accent);
  background:rgba(200,65,10,0.06); border-top:1px solid rgba(200,65,10,0.2);
}

/* Collapsible breakdown */
.toggle-breakdown {
  font-size:10px; color:var(--muted); cursor:pointer;
  text-decoration:underline; padding:0 16px 10px; display:block;
}
.s-breakdown { display:none; }
.s-breakdown.open { display:grid; }

/* Export bar */
.export-bar {
  display:flex; gap:10px; margin-top:20px; flex-wrap:wrap; align-items:center;
}
.export-bar label { font-size:11px; color:var(--muted); }

/* error */
.err-box {
  background:rgba(200,65,10,0.08); border:1.5px solid var(--accent);
  border-radius:4px; padding:14px 18px; font-size:12px; color:var(--accent);
  display:none; margin-bottom:16px;
}
</style>
</head>
<body>
<div class="page">

  <header>
    <div class="brand">
      <h1>GradeAI</h1>
      <span class="version">v2.0</span>
    </div>
    <div class="header-sub">
      AI-Powered Bubble Sheet Grader ¬∑ BMCC<br>
      <span style="font-size:10px;">Powered by Google Gemini (free)</span><br>
      <div style="margin-top:8px;display:flex;align-items:center;gap:8px;">
        <span style="font-size:10px;color:var(--muted);">API Key:</span>
        <input id="gemini-key-input" type="password" placeholder="Paste your Gemini API key"
          style="font-family:'IBM Plex Mono';font-size:11px;padding:5px 10px;border:1.5px solid var(--border);
          border-radius:3px;background:var(--surface);color:var(--ink);width:260px;outline:none;"
          oninput="updateGeminiKey(this.value)">
        <a href="https://aistudio.google.com/app/apikey" target="_blank"
          style="font-size:10px;color:var(--accent3);">Get free key ‚Üó</a>
      </div>
    </div>
  </header>

  <!-- Pipeline -->
  <div class="pipeline">
    <div class="pipe-step active" id="ps1">
      <div class="pipe-num">01</div>
      <div class="pipe-label">Answer Key Sheet</div>
    </div>
    <div class="pipe-step" id="ps2">
      <div class="pipe-num">02</div>
      <div class="pipe-label">Student Sheets</div>
    </div>
    <div class="pipe-step" id="ps3">
      <div class="pipe-num">03</div>
      <div class="pipe-label">Grade</div>
    </div>
    <div class="pipe-step" id="ps4">
      <div class="pipe-num">04</div>
      <div class="pipe-label">Results</div>
    </div>
  </div>

  <!-- STEP 1: Answer Key -->
  <div class="panel" id="panel-key">
    <div class="panel-head">
      STEP 1 ‚Äî ANSWER KEY
      <span class="badge">PROFESSOR'S MASTER SHEET</span>
    </div>
    <div class="panel-body">
      <p style="font-size:11px;color:var(--muted);margin-bottom:16px;">Upload a photo of the <strong>completed answer sheet you filled out as the key</strong>. The AI will extract all correct answers automatically.</p>
      
      <div class="two-col">
        <div>
          <div class="upload-zone" id="key-drop">
            <input type="file" id="key-upload" accept="image/*,.pdf,application/pdf">
            <div class="upload-icon">üóùÔ∏è</div>
            <div class="upload-label"><strong>Upload key sheet</strong><br>Image or PDF scan</div>
          </div>
          <div id="key-preview-wrap">
            <img id="key-preview" src="" alt="">
          </div>
        </div>
        <div>
          <div class="key-status" id="key-status"></div>
          <div class="controls" style="margin-top:0;margin-bottom:12px;">
            <div class="num-q-row">
              <label>Questions on exam:</label>
              <input type="number" id="num-questions" value="100" min="1" max="120">
            </div>
            <button class="btn btn-ghost" onclick="extractKey()" id="extract-btn" disabled>‚ö° Extract Key</button>
          </div>
          <div id="extracted-key-preview" style="font-size:11px;color:var(--muted);line-height:2;"></div>
        </div>
      </div>

      <span class="toggle-manual" onclick="toggleManual()">‚Üì Or enter key manually instead</span>
      <div id="manual-section">
        <div class="bulk-row">
          <label>Paste all answers:</label>
          <input type="text" id="bulk-key" placeholder="A,B,C,D,A,B,...">
          <button class="btn btn-ghost" onclick="parseBulkKey()">Apply</button>
        </div>
        <div class="key-grid" id="key-grid"></div>
      </div>
    </div>
  </div>

  <!-- STEP 2: Student Sheets -->
  <div class="panel" id="panel-students">
    <div class="panel-head">
      STEP 2 ‚Äî STUDENT SHEETS
      <span class="badge">UPLOAD MULTIPLE</span>
    </div>
    <div class="panel-body">
      <p style="font-size:11px;color:var(--muted);margin-bottom:16px;">Upload one or more student answer sheets. You can add them all at once or one by one.</p>
      <div class="upload-zone" id="student-drop">
        <input type="file" id="student-upload" accept="image/*,.pdf,application/pdf" multiple>
        <div class="upload-icon">üìö</div>
        <div class="upload-label"><strong>Upload student sheets</strong><br>Images or PDFs ‚Äî select multiple</div>
      </div>
      <div class="thumb-row" id="student-thumbs"></div>
    </div>
  </div>

  <div class="err-box" id="err-box"></div>

  <!-- DEBUG PANEL -->
  <div id="debug-panel" style="display:none;margin-top:16px;">
    <div style="font-family:'IBM Plex Mono',monospace;font-size:10px;background:#111;color:#0f0;padding:16px;border-radius:4px;max-height:300px;overflow-y:auto;white-space:pre-wrap;word-break:break-all;" id="debug-log"></div>
    <button onclick="document.getElementById('debug-panel').style.display='none'" style="margin-top:8px;font-size:11px;padding:4px 10px;cursor:pointer;">Hide</button>
    <button onclick="document.getElementById('debug-log').textContent=''" style="margin-top:8px;margin-left:8px;font-size:11px;padding:4px 10px;cursor:pointer;">Clear</button>
  </div>

  <div id="grade-hint" style="display:none;font-size:11px;color:var(--accent);margin-bottom:8px;padding:10px 14px;background:rgba(200,65,10,0.07);border:1px solid rgba(200,65,10,0.25);border-radius:4px;"></div>

  <!-- Grade button -->
  <button class="btn btn-go" id="grade-btn" onclick="gradeAll()" disabled>
    GRADE ALL SHEETS ‚Üí
  </button>

  <!-- Loading -->
  <div id="loading">
    <div class="spinner-wrap">
      <div class="spinner-ring"></div>
      <div class="spinner-inner"></div>
    </div>
    <div class="loading-title" id="loading-title">GRADING SHEETS</div>
    <div class="loading-sub" id="loading-sub">Analyzing with Claude Vision AI...</div>
    <div class="progress-bar-wrap">
      <div class="progress-bar" id="progress-bar"></div>
    </div>
  </div>

  <!-- Results -->
  <div id="results">
    <div class="panel">
      <div class="panel-head">
        RESULTS
        <span class="badge" id="results-badge">0 STUDENTS</span>
      </div>
      <div class="panel-body">
        <div class="results-summary" id="results-summary"></div>
        <div class="student-results" id="student-results"></div>
        <div class="export-bar">
          <label>Export:</label>
          <button class="btn btn-ghost" onclick="exportCSV()">Download CSV</button>
          <button class="btn btn-ghost" onclick="resetAll()">‚Üê Grade New Batch</button>
        </div>
      </div>
    </div>
  </div>

</div>
<script>
// ‚îÄ‚îÄ FILE HANDLING ‚Äî zero external dependencies ‚îÄ‚îÄ
// Images ‚Üí FileReader ‚Üí base64. PDFs ‚Üí base64 sent as Claude document blocks.
// No PDF.js, no CDN, no iframe tricks needed.

async function fileToImages(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = e => {
      const base64 = e.target.result.split(',')[1];
      const isPdf = file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf');
      const dataUrl = e.target.result;
      // For PDFs we can't show a preview image, so use a placeholder
      const previewUrl = isPdf
        ? 'data:image/svg+xml,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="300" height="200"><rect width="300" height="200" fill="#ede8de" rx="4"/><text x="150" y="90" text-anchor="middle" font-family="monospace" font-size="13" fill="#8c7e66">üìÑ PDF loaded</text><text x="150" y="115" text-anchor="middle" font-family="monospace" font-size="11" fill="#8c7e66">' + file.name + '</text><text x="150" y="140" text-anchor="middle" font-family="monospace" font-size="10" fill="#b0a090">Ready to extract</text></svg>')
        : dataUrl;
      resolve([{ base64, type: isPdf ? 'application/pdf' : (file.type || 'image/jpeg'), dataUrl: previewUrl, originalDataUrl: dataUrl, isPdf }]);
    };
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

// ‚îÄ‚îÄ GEMINI API ‚Äî free tier, no proxy needed ‚îÄ‚îÄ
// Get your free API key at: https://aistudio.google.com/app/apikey
const GEMINI_API_KEY = 'YOUR_GEMINI_API_KEY';
const GEMINI_MODEL = 'gemini-1.5-flash';

// ‚îÄ‚îÄ DEBUG ‚îÄ‚îÄ
function debugLog(msg) {
  console.log(msg);
  const panel = document.getElementById('debug-panel');
  const log = document.getElementById('debug-log');
  panel.style.display = 'block';
  log.textContent += msg + '\n---\n';
  log.scrollTop = log.scrollHeight;
}

// ‚îÄ‚îÄ GEMINI API HELPER ‚îÄ‚îÄ
async function callGemini(prompt, imageB64, imageType, isPdf) {
  const key = window._geminiKey || GEMINI_API_KEY;
  if (!key || key === 'YOUR_GEMINI_API_KEY') throw new Error('Please enter your Gemini API key at the top of the page');
  const url = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${key}`;
  
  let parts = [];
  
  if (isPdf) {
    parts.push({ inline_data: { mime_type: 'application/pdf', data: imageB64 } });
  } else if (imageB64) {
    parts.push({ inline_data: { mime_type: imageType || 'image/jpeg', data: imageB64 } });
  }
  parts.push({ text: prompt });

  const resp = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      contents: [{ parts }],
      generationConfig: { temperature: 0, maxOutputTokens: 600 }
    })
  });

  const data = await resp.json();
  if (!resp.ok || data.error) throw new Error(data.error?.message || 'Gemini API error');
  return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
}

function updateGeminiKey(val) {
  // Update the key constant dynamically
  window._geminiKey = val.trim();
}

// ‚îÄ‚îÄ STATE ‚îÄ‚îÄ
let keyImage = null;       // {base64, type, name}
let keyAnswers = {};       // {1:'A', 2:'B', ...}
let keyExtracted = false;
let studentFiles = [];     // [{id, base64, type, name, file}]
let gradingResults = [];   // [{id, name, result, error}]
let nextStudentId = 1;

// ‚îÄ‚îÄ PIPELINE ‚îÄ‚îÄ
function setPipe(n) {
  [1,2,3,4].forEach(i => {
    const el = document.getElementById(`ps${i}`);
    el.className = `pipe-step ${i < n ? 'done' : i === n ? 'active' : ''}`;
  });
}

// ‚îÄ‚îÄ KEY SHEET UPLOAD ‚îÄ‚îÄ
const keyDrop = document.getElementById('key-drop');
const keyInput = document.getElementById('key-upload');
keyDrop.addEventListener('dragover', e=>{ e.preventDefault(); keyDrop.classList.add('dragover'); });
keyDrop.addEventListener('dragleave', ()=> keyDrop.classList.remove('dragover'));
keyDrop.addEventListener('drop', e=>{ e.preventDefault(); keyDrop.classList.remove('dragover'); if(e.dataTransfer.files[0]) handleKeyFile(e.dataTransfer.files[0]); });
keyInput.addEventListener('change', ()=>{ if(keyInput.files[0]) handleKeyFile(keyInput.files[0]); });

async function handleKeyFile(f) {
  const status = document.getElementById('key-status');
  status.style.display = 'block';
  status.className = 'key-status';
  status.textContent = f.name.toLowerCase().endsWith('.pdf') ? '‚è≥ Converting PDF page to image...' : '‚è≥ Loading...';

  try {
    const images = await fileToImages(f);
    // For key sheet, use first page only
    keyImage = { base64: images[0].base64, type: images[0].type, name: f.name, isPdf: images[0].isPdf || false, dataUrl: images[0].dataUrl };
    document.getElementById('key-preview').src = images[0].isPdf ? 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="260"><rect width="200" height="260" fill="%23eee"/><text x="100" y="130" text-anchor="middle" font-size="14" fill="%23666">PDF Ready</text><text x="100" y="155" text-anchor="middle" font-size="11" fill="%23999">' + f.name + '</text></svg>' : images[0].dataUrl;
    document.getElementById('key-preview-wrap').style.display = 'block';
    keyDrop.classList.add('has-file');
    document.getElementById('extract-btn').disabled = false;
    keyExtracted = false;
    status.style.display = 'none';
    checkGradeReady();
  } catch(err) {
    status.className = 'key-status err';
    status.textContent = `‚úó Failed to load file: ${err.message}`;
  }
  setPipe(2);
}

// ‚îÄ‚îÄ EXTRACT KEY ‚îÄ‚îÄ
// For PDFs: send whole PDF as Claude document block (native support, no library needed)
// For images: crop into 4 columns and send each separately for accuracy
async function extractKey() {
  if (!keyImage) return;
  const btn = document.getElementById('extract-btn');
  const numQ = parseInt(document.getElementById('num-questions').value) || 100;
  btn.disabled = true;

  const status = document.getElementById('key-status');
  status.style.display = 'block';
  status.className = 'key-status';

  try {
    const mergedAnswers = {};

    if (keyImage.isPdf) {
      // ‚îÄ‚îÄ PDF PATH: send full PDF, ask Claude to read all columns ‚îÄ‚îÄ
      status.textContent = '‚è≥ Sending PDF to Claude...';
      const numCols = 4;
      const qPerCol = Math.ceil(numQ / numCols);

      for (let col = 0; col < numCols; col++) {
        const startQ = col * qPerCol + 1;
        const endQ = Math.min(startQ + qPerCol - 1, numQ);
        if (startQ > numQ) break;

        status.textContent = `‚è≥ Reading column ${col+1}/4 (Q${startQ}‚Äì${endQ})...`;

        const prompt = `This is a scanned answer sheet PDF. It has 4 columns of bubble questions side by side.
I need you to read ONLY the ${col+1}${col===0?'st':col===1?'nd':col===2?'rd':'th'} column from the left, which contains questions ${startQ} through ${endQ}.
Each row in that column has a question number and 4 bubbles labeled A, B, C, D. One bubble is filled/darkened.

Return ONLY a JSON object mapping question number to the filled answer letter:
{"${startQ}":"A","${startQ+1}":"C",...,"${endQ}":"B"}

No markdown, no explanation. Just the JSON.`;

        const raw = await callGemini(prompt, keyImage.base64, 'application/pdf', true);
        debugLog('PDF col ' + (col+1) + ' raw: ' + raw.slice(0,100));
        debugLog('PDF col ' + (col+1) + ' raw: ' + raw);
        const m = raw.match(/\{[\s\S]*\}/);
        if (!m) throw new Error('No JSON in col ' + (col+1) + ': ' + raw.slice(0, 200));
        const parsed = JSON.parse(m[0]);
        Object.entries(parsed).forEach(([k, v]) => { mergedAnswers[parseInt(k)] = v; });
        debugLog('After col ' + (col+1) + ': ' + JSON.stringify(mergedAnswers).slice(0, 200));
        if (col < numCols - 1) await new Promise(r => setTimeout(r, 250));
      }

    } else {
      // ‚îÄ‚îÄ IMAGE PATH: crop 4 columns and send each as image ‚îÄ‚îÄ
      status.textContent = '‚è≥ Preparing image...';
      const fullCanvas = await imageToCanvas(keyImage.originalDataUrl || keyImage.dataUrl, 3.0);
      const W = fullCanvas.width;
      const H = fullCanvas.height;
      const gridTop = Math.floor(H * 0.17);
      const gridBot = Math.floor(H * 0.97);
      const gridH = gridBot - gridTop;
      const numCols = 4;
      const colW = Math.floor(W / numCols);
      const qPerCol = Math.ceil(numQ / numCols);

      for (let col = 0; col < numCols; col++) {
        const startQ = col * qPerCol + 1;
        const endQ = Math.min(startQ + qPerCol - 1, numQ);
        if (startQ > numQ) break;

        status.textContent = `‚è≥ Reading column ${col+1}/4 (Q${startQ}‚Äì${endQ})...`;
        const x0 = col * colW;
        const colCanvas = cropCanvas(fullCanvas, x0, gridTop, colW, gridH);
        const scaled = scaleCanvas(colCanvas, 2.0);
        const b64 = scaled.toDataURL('image/jpeg', 0.95).split(',')[1];

        const prompt = `This image shows ONE vertical column from a multiple-choice bubble sheet.
It contains questions ${startQ} through ${endQ}, top to bottom.
Each row: question number on the left, then 4 bubbles A B C D. ONE is filled/darkened.

Return ONLY JSON ‚Äî no markdown, no explanation:
{"${startQ}":"A","${startQ+1}":"C",...,"${endQ}":"B"}

Include all ${endQ - startQ + 1} questions.`;

        const raw = await callGemini(prompt, b64, 'image/jpeg', false);
        debugLog('IMG col ' + (col+1) + ' raw: ' + raw.slice(0,100));
        debugLog('IMG col ' + (col+1) + ' raw: ' + raw);
        const m = raw.match(/\{[\s\S]*\}/);
        if (!m) throw new Error('No JSON found for col ' + (col+1) + ': ' + raw.slice(0, 200));
        const parsed = JSON.parse(m[0]);
        Object.entries(parsed).forEach(([k, v]) => { mergedAnswers[parseInt(k)] = v; });
        if (col < numCols - 1) await new Promise(r => setTimeout(r, 250));
      }
    }

    keyAnswers = mergedAnswers;
    keyExtracted = true;

    const preview = document.getElementById('extracted-key-preview');
    let html = '<div style="font-size:10px;color:var(--muted);margin-bottom:8px;letter-spacing:0.08em;">EXTRACTED ANSWERS ‚Äî click any chip to correct:</div>';
    html += '<div style="display:flex;flex-wrap:wrap;gap:5px;">';
    for (let i = 1; i <= numQ; i++) {
      const ans = mergedAnswers[i] || '?';
      const bad = !['A','B','C','D'].includes(ans);
      html += `<span id="kchip-${i}" onclick="editKeyChip(${i})"
        style="background:var(--surface2);border:1.5px solid ${bad?'var(--accent)':'var(--border)'};
        border-radius:3px;padding:3px 8px;font-size:11px;cursor:pointer;user-select:none;
        color:${bad?'var(--accent)':'var(--ink)'}">Q${i}:<strong>${ans}</strong></span>`;
    }
    html += '</div>';
    preview.innerHTML = html;

    const badCount = Object.values(mergedAnswers).filter(v => !['A','B','C','D'].includes(v)).length;
    status.className = 'key-status ok';
    status.textContent = `‚úì Key extracted ‚Äî ${Object.keys(mergedAnswers).length} questions${badCount > 0 ? ' ¬∑ ' + badCount + ' uncertain (red ‚Äî click to fix)' : ' ¬∑ All clear!'}`;
    buildKeyGrid(keyAnswers);
    checkGradeReady();

  } catch(err) {
    status.className = 'key-status err';
    status.textContent = '‚úó ' + err.message;
    debugLog('ERROR: ' + err.message);
  }

  btn.disabled = false;
  btn.textContent = '‚ö° Extract Key';
}


// Click a chip to manually correct it
function editKeyChip(q) {
  const current = keyAnswers[q] || keyAnswers[String(q)] || '';
  const choices = ['A','B','C','D'];
  const next = choices[(choices.indexOf(current) + 1) % choices.length] || 'A';
  keyAnswers[q] = next;
  keyAnswers[String(q)] = next;
  const chip = document.getElementById(`kchip-${q}`);
  if (chip) {
    chip.innerHTML = `Q${q}:<strong>${next}</strong>`;
    chip.style.borderColor = 'var(--accent2)';
    chip.style.color = 'var(--ink)';
    setTimeout(() => { if(chip) chip.style.borderColor = 'var(--border)'; }, 800);
  }
  // Also sync the manual grid select if open
  const sel = document.getElementById(`kg-${q}`);
  if (sel) sel.value = next;
  checkGradeReady();
}

// ‚îÄ‚îÄ CANVAS HELPERS ‚îÄ‚îÄ
function imageToCanvas(dataUrl, scale = 1) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const c = document.createElement('canvas');
      c.width = img.naturalWidth * scale;
      c.height = img.naturalHeight * scale;
      const ctx = c.getContext('2d');
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(img, 0, 0, c.width, c.height);
      resolve(c);
    };
    img.onerror = reject;
    img.src = dataUrl;
  });
}

function cropCanvas(src, x, y, w, h) {
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  c.getContext('2d').drawImage(src, x, y, w, h, 0, 0, w, h);
  return c;
}

function scaleCanvas(src, scale) {
  const c = document.createElement('canvas');
  c.width = src.width * scale;
  c.height = src.height * scale;
  const ctx = c.getContext('2d');
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
  ctx.drawImage(src, 0, 0, c.width, c.height);
  return c;
}

// ‚îÄ‚îÄ MANUAL KEY ‚îÄ‚îÄ
function toggleManual() {
  const s = document.getElementById('manual-section');
  s.style.display = s.style.display==='none' ? 'block' : 'none';
  if(s.style.display==='block' && document.getElementById('key-grid').children.length===0) buildKeyGrid();
}
function buildKeyGrid(vals={}) {
  const n = parseInt(document.getElementById('num-questions').value)||20;
  const g = document.getElementById('key-grid');
  g.innerHTML='';
  for(let i=1;i<=n;i++){
    const d=document.createElement('div'); d.className='kg-item';
    d.innerHTML=`<label>${i}</label><select id="kg-${i}" onchange="onManualKeyChange()">
      <option value="">‚Äî</option>
      <option value="A" ${vals[i]==='A'?'selected':''}>A</option>
      <option value="B" ${vals[i]==='B'?'selected':''}>B</option>
      <option value="C" ${vals[i]==='C'?'selected':''}>C</option>
      <option value="D" ${vals[i]==='D'?'selected':''}>D</option>
    </select>`;
    g.appendChild(d);
  }
}
function onManualKeyChange() {
  const n=parseInt(document.getElementById('num-questions').value)||20;
  keyAnswers={};
  for(let i=1;i<=n;i++){
    const s=document.getElementById(`kg-${i}`);
    if(s&&s.value) keyAnswers[i]=s.value;
  }
  keyExtracted = Object.keys(keyAnswers).length > 0;
  checkGradeReady();
}
function parseBulkKey(){
  const raw=document.getElementById('bulk-key').value.toUpperCase();
  const ans=raw.split(/[,\s]+/).filter(x=>/^[ABCD]$/.test(x));
  if(!ans.length) return;
  document.getElementById('num-questions').value=ans.length;
  const vals={};
  ans.forEach((a,i)=>{vals[i+1]=a;});
  buildKeyGrid(vals);
  onManualKeyChange();
}

// ‚îÄ‚îÄ STUDENT FILES ‚îÄ‚îÄ
const studentDrop = document.getElementById('student-drop');
const studentInput = document.getElementById('student-upload');
studentDrop.addEventListener('dragover', e=>{e.preventDefault();studentDrop.classList.add('dragover');});
studentDrop.addEventListener('dragleave',()=>studentDrop.classList.remove('dragover'));
studentDrop.addEventListener('drop',e=>{e.preventDefault();studentDrop.classList.remove('dragover');[...e.dataTransfer.files].forEach(f=>addStudentFile(f));});
studentInput.addEventListener('change',()=>{[...studentInput.files].forEach(f=>addStudentFile(f)); studentInput.value='';});

async function addStudentFile(f) {
  const isPdf = f.type === 'application/pdf' || f.name.toLowerCase().endsWith('.pdf');
  try {
    const images = await fileToImages(f);
    images.forEach((img, pageIdx) => {
      const id = nextStudentId++;
      const label = isPdf && images.length > 1
        ? `${f.name} (p.${pageIdx+1})`
        : f.name;
      studentFiles.push({ id, base64: img.base64, type: img.type, name: label, dataUrl: img.dataUrl, originalDataUrl: img.originalDataUrl, isPdf: img.isPdf || false });
    });
    renderStudentThumbs();
    checkGradeReady();
  } catch(err) {
    showErr(`Failed to load ${f.name}: ${err.message}`);
  }
}
function removeStudent(id) {
  studentFiles = studentFiles.filter(s=>s.id!==id);
  renderStudentThumbs();
  checkGradeReady();
}
function renderStudentThumbs() {
  const wrap = document.getElementById('student-thumbs');
  wrap.innerHTML='';
  studentFiles.forEach(s=>{
    const d=document.createElement('div'); d.className='thumb';
    d.innerHTML=`<img src="${s.dataUrl}" alt="">
      <button class="rm" onclick="removeStudent(${s.id})">√ó</button>
      <div class="thumb-name">${s.name}</div>`;
    wrap.appendChild(d);
  });
  if(studentFiles.length>0) setPipe(3);
}

function checkGradeReady() {
  const hasStudents = studentFiles.length > 0;
  const hasKey = keyExtracted || Object.keys(keyAnswers).length > 0;
  const btn = document.getElementById('grade-btn');
  btn.style.display = 'block';
  btn.disabled = !(hasStudents && hasKey);
  // Show a helpful hint if students loaded but no key yet
  const hint = document.getElementById('grade-hint');
  if (hint) {
    if (hasStudents && !hasKey) {
      hint.style.display = 'block';
      hint.textContent = '‚ö† Please extract or enter an answer key before grading.';
    } else {
      hint.style.display = 'none';
    }
  }
}

function showErr(msg) {
  const el = document.getElementById('err-box');
  el.textContent = msg;
  el.style.display = 'block';
}

// ‚îÄ‚îÄ GRADE ALL ‚îÄ‚îÄ
async function gradeAll() {
  const numQ = parseInt(document.getElementById('num-questions').value)||20;

  document.getElementById('grade-btn').style.display='none';
  document.getElementById('loading').style.display='block';
  document.getElementById('results').style.display='none';
  document.getElementById('err-box').style.display='none';
  setPipe(4);

  gradingResults = [];
  const total = studentFiles.length;

  for(let i=0; i<total; i++) {
    const s = studentFiles[i];
    const pct = Math.round(((i)/total)*100);
    document.getElementById('progress-bar').style.width = pct+'%';
    document.getElementById('loading-title').textContent = `GRADING ${i+1} OF ${total}`;
    document.getElementById('loading-sub').textContent = `Processing: ${s.name}`;

    try {
      const result = await gradeOneSheet(s, numQ, keyAnswers);
      gradingResults.push({id:s.id, name:s.name, dataUrl:s.dataUrl, result, error:null});
    } catch(err) {
      gradingResults.push({id:s.id, name:s.name, dataUrl:s.dataUrl, result:null, error:err.message});
    }
  }

  document.getElementById('progress-bar').style.width='100%';
  await new Promise(r=>setTimeout(r,400));
  document.getElementById('loading').style.display='none';
  document.getElementById('grade-btn').style.display='block';
  renderResults();
}

async function gradeOneSheet(s, numQ, keyAnswers) {
  const numCols = 4;
  const qPerCol = Math.ceil(numQ / numCols);
  const detectedAnswers = {};

  if (s.isPdf) {
    // Send full PDF with per-column prompts
    for (let col = 0; col < numCols; col++) {
      const startQ = col * qPerCol + 1;
      const endQ = Math.min(startQ + qPerCol - 1, numQ);
      if (startQ > numQ) break;

      const keySnippet = [];
      for (let q = startQ; q <= endQ; q++) {
        if (keyAnswers[q]) keySnippet.push('Q' + q + ':' + keyAnswers[q]);
      }

      const prompt = `This is a scanned answer sheet PDF with 4 columns of bubble questions side by side.
Read ONLY the ${col+1}${col===0?'st':col===1?'nd':col===2?'rd':'th'} column from the left, which contains questions ${startQ} through ${endQ}.
Each row has a question number and bubbles A, B, C, D. One bubble is filled by the student.

Correct answers for this column: ${keySnippet.join(', ')}

Return ONLY JSON with the STUDENT'S answer for each question:
{"${startQ}":"A",...,"${endQ}":"B"}
Use "blank" if no bubble is filled. No markdown, no explanation.`;

      const raw = await callGemini(prompt, s.base64, 'application/pdf', true);
      const m = raw.match(/\{[\s\S]*\}/);
      if (!m) throw new Error('Could not parse col ' + (col+1));
      const parsed = JSON.parse(m[0]);
      Object.entries(parsed).forEach(([k, v]) => { detectedAnswers[parseInt(k)] = v; });
      if (col < numCols - 1) await new Promise(r => setTimeout(r, 200));
    }
  } else {
    // Image: crop columns
    const fullCanvas = await imageToCanvas(s.originalDataUrl || s.dataUrl, 3.0);
    const W = fullCanvas.width, H = fullCanvas.height;
    const gridTop = Math.floor(H * 0.17), gridBot = Math.floor(H * 0.97);
    const colW = Math.floor(W / numCols);

    for (let col = 0; col < numCols; col++) {
      const startQ = col * qPerCol + 1;
      const endQ = Math.min(startQ + qPerCol - 1, numQ);
      if (startQ > numQ) break;

      const keySnippet = [];
      for (let q = startQ; q <= endQ; q++) {
        if (keyAnswers[q]) keySnippet.push('Q' + q + ':' + keyAnswers[q]);
      }

      const colCanvas = cropCanvas(fullCanvas, col * colW, gridTop, colW, gridBot - gridTop);
      const b64 = scaleCanvas(colCanvas, 2.0).toDataURL('image/jpeg', 0.95).split(',')[1];

      const prompt = `This image is ONE column from a student answer sheet, questions ${startQ} to ${endQ} top to bottom.
Each row: question number left, then bubbles A B C D. One is filled.
Correct answers: ${keySnippet.join(', ')}
Return ONLY JSON with the student's answer: {"${startQ}":"A",...,"${endQ}":"B"}
Use "blank" if empty. No markdown.`;

      const raw = await callGemini(prompt, b64, 'image/jpeg', false);
      const m = raw.match(/\{[\s\S]*\}/);
      if (!m) throw new Error('Could not parse col ' + (col+1));
      const parsed = JSON.parse(m[0]);
      Object.entries(parsed).forEach(([k, v]) => { detectedAnswers[parseInt(k)] = v; });
      if (col < numCols - 1) await new Promise(r => setTimeout(r, 200));
    }
  }

  let correct = 0;
  const wrong = [], blank = [];
  for (let q = 1; q <= numQ; q++) {
    const studentAns = detectedAnswers[q] || 'blank';
    const keyAns = keyAnswers[q];
    if (studentAns === 'blank') blank.push(q);
    else if (studentAns === keyAns) correct++;
    else wrong.push(q);
  }
  return { detected_answers: detectedAnswers, correct_count: correct, total_questions: numQ, wrong_questions: wrong, blank_questions: blank };
}


// ‚îÄ‚îÄ RENDER RESULTS ‚îÄ‚îÄ
function getGrade(pct) {
  if(pct>=93)return{g:'A',c:'A'};
  if(pct>=90)return{g:'A‚àí',c:'A'};
  if(pct>=87)return{g:'B+',c:'B'};
  if(pct>=83)return{g:'B',c:'B'};
  if(pct>=80)return{g:'B‚àí',c:'B'};
  if(pct>=77)return{g:'C+',c:'C'};
  if(pct>=73)return{g:'C',c:'C'};
  if(pct>=70)return{g:'C‚àí',c:'C'};
  if(pct>=60)return{g:'D',c:'D'};
  return{g:'F',c:'F'};
}

function renderResults() {
  const numQ = parseInt(document.getElementById('num-questions').value)||20;
  const successful = gradingResults.filter(r=>r.result);
  const failed = gradingResults.filter(r=>r.error);

  document.getElementById('results-badge').textContent = `${gradingResults.length} STUDENTS`;

  // Summary stats
  if(successful.length>0) {
    const scores = successful.map(r=>Math.round((r.result.correct_count/numQ)*100));
    const avg = Math.round(scores.reduce((a,b)=>a+b,0)/scores.length);
    const highest = Math.max(...scores);
    const lowest = Math.min(...scores);
    const passing = scores.filter(s=>s>=60).length;

    document.getElementById('results-summary').innerHTML = `
      <div class="summary-stat"><div class="val accent">${avg}%</div><div class="lbl">Class Average</div></div>
      <div class="summary-divider"></div>
      <div class="summary-stat"><div class="val">${highest}%</div><div class="lbl">Highest</div></div>
      <div class="summary-divider"></div>
      <div class="summary-stat"><div class="val">${lowest}%</div><div class="lbl">Lowest</div></div>
      <div class="summary-divider"></div>
      <div class="summary-stat"><div class="val accent">${passing}</div><div class="lbl">Passing (‚â•60%)</div></div>
      <div class="summary-divider"></div>
      <div class="summary-stat"><div class="val err">${successful.length-passing}</div><div class="lbl">Failing</div></div>
      ${failed.length>0?`<div class="summary-divider"></div><div class="summary-stat"><div class="val err">${failed.length}</div><div class="lbl">Errors</div></div>`:''}
    `;
  }

  // Individual cards
  const container = document.getElementById('student-results');
  container.innerHTML='';

  gradingResults.forEach((r,idx)=>{
    const card = document.createElement('div');
    card.className='student-card';

    if(r.error) {
      card.innerHTML=`
        <div class="student-card-head">
          <img class="s-thumb" src="${r.dataUrl}" alt="">
          <div class="s-name">${r.name}</div>
          <span class="s-score-chip ERR">ERROR</span>
        </div>
        <div class="error-note">‚ö† ${r.error}</div>`;
    } else {
      const res = r.result;
      const correct = res.correct_count||0;
      const pct = Math.round((correct/numQ)*100);
      const {g,c} = getGrade(pct);
      const wrong = res.wrong_questions||[];
      const blank = res.blank_questions||[];
      const detected = res.detected_answers||{};

      let breakdownHtml='';
      for(let i=1;i<=numQ;i++){
        const sAns = detected[i]||detected[String(i)]||'‚Äî';
        const kAns = keyAnswers[i]||'?';
        const isBlank=blank.includes(i);
        const isWrong=wrong.includes(i);
        const isCorrect=!isWrong&&!isBlank&&sAns!=='‚Äî';
        breakdownHtml+=`<div class="s-item ${isBlank?'blank':isCorrect?'correct':'wrong'}">
          <span class="s-qnum">Q${i}</span>
          <span class="s-ans">${sAns}</span>
          <span class="s-keyans">/ ${kAns}</span>
          <span class="s-icon">${isBlank?'‚óã':isCorrect?'‚úì':'‚úó'}</span>
        </div>`;
      }

      const cardId='card-'+idx;
      card.innerHTML=`
        <div class="student-card-head">
          <img class="s-thumb" src="${r.dataUrl}" alt="">
          <div class="s-name">${r.name}</div>
          <span class="s-score-chip ${c}">${correct}/${numQ} ¬∑ ${pct}% ¬∑ ${g}</span>
        </div>
        <span class="toggle-breakdown" onclick="toggleBreakdown('${cardId}')">‚ñ∏ Show answer breakdown</span>
        <div class="s-breakdown" id="${cardId}">${breakdownHtml}</div>`;
    }
    container.appendChild(card);
  });

  document.getElementById('results').style.display='block';
  document.getElementById('grade-btn').style.display='block';
}

function toggleBreakdown(id) {
  const el=document.getElementById(id);
  const toggle=el.previousElementSibling;
  el.classList.toggle('open');
  toggle.textContent=el.classList.contains('open')?'‚ñæ Hide answer breakdown':'‚ñ∏ Show answer breakdown';
}

// ‚îÄ‚îÄ EXPORT CSV ‚îÄ‚îÄ
function exportCSV() {
  const numQ = parseInt(document.getElementById('num-questions').value)||20;
  let csv='File Name,Correct,Total,Percentage,Grade\n';
  gradingResults.forEach(r=>{
    if(r.error){
      csv+=`"${r.name}",ERROR,${numQ},,\n`;
    } else {
      const correct=r.result.correct_count||0;
      const pct=Math.round((correct/numQ)*100);
      const {g}=getGrade(pct);
      csv+=`"${r.name}",${correct},${numQ},${pct}%,${g}\n`;
    }
  });
  const blob=new Blob([csv],{type:'text/csv'});
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob);
  a.download='grades.csv';
  a.click();
}

// ‚îÄ‚îÄ RESET ‚îÄ‚îÄ
function resetAll() {
  keyImage=null; keyAnswers={}; keyExtracted=false;
  studentFiles=[]; gradingResults=[]; nextStudentId=1;
  document.getElementById('key-preview-wrap').style.display='none';
  document.getElementById('key-status').style.display='none';
  document.getElementById('extracted-key-preview').innerHTML='';
  document.getElementById('student-thumbs').innerHTML='';
  document.getElementById('results').style.display='none';
  document.getElementById('grade-btn').disabled=true;
  document.getElementById('extract-btn').disabled=true;
  document.getElementById('key-grid').innerHTML='';
  setPipe(1);
}
</script>
</body>
</html>
